# CryptoCore

Консольный криптографический инструмент для шифрования и дешифрования файлов с использованием блочных шифров.

## Возможности

- **Шифрование/дешифрование AES-128** в нескольких режимах работы:
  - **ECB** (Electronic Codebook) - базовый режим
  - **CBC** (Cipher Block Chaining) - цепочка блоков
  - **CFB** (Cipher Feedback) - обратная связь по шифртексту
  - **OFB** (Output Feedback) - обратная связь по выходу
  - **CTR** (Counter) - счетчик
- **Дополнение PKCS#7** для режимов ECB и CBC
- **Автоматическая генерация IV** для режимов с вектором инициализации
- **Безопасная работа с бинарными данными** для текстовых и бинарных файлов
- **Интеграция с OpenSSL** для безопасных криптографических операций AES
- **Совместимость с OpenSSL** - возможность шифровать/дешифровать файлы между CryptoCore и OpenSSL
- **Простой CLI-интерфейс** для легкого шифрования и дешифрования файлов

## Зависимости

Перед сборкой CryptoCore убедитесь, что у вас установлено следующее:

- **Компилятор C**: GCC или Clang
- **Библиотеки разработки OpenSSL**: 
  - На Ubuntu/Debian: `sudo apt-get install libssl-dev`
  - На Fedora/RHEL: `sudo dnf install openssl-devel`
  - На macOS: `brew install openssl` (обычно уже установлен)
  - На Windows: См. [WINDOWS_BUILD.md](WINDOWS_BUILD.md) для подробных инструкций
- **Make**: Инструмент автоматизации сборки (обычно предустановлен на Linux/macOS)

> **Пользователям Windows**: Пожалуйста, прочитайте [WINDOWS_BUILD.md](WINDOWS_BUILD.md) для полных инструкций по сборке на Windows, включая установку OpenSSL и GCC.

## Инструкции по сборке

1. **Клонируйте или скачайте репозиторий**

2. **Перейдите в директорию проекта**:
   ```bash
   cd cryptocore
   ```

3. **Соберите проект**:
   ```bash
   make
   ```

   Это скомпилирует исходный код и создаст исполняемый файл `cryptocore` в текущей директории.

4. **(Опционально) Установите в систему**:
   ```bash
   sudo make install
   ```

   Это установит `cryptocore` в `/usr/local/bin/`, делая его доступным из любого места.

## Использование

### Синтаксис команды

```bash
cryptocore --algorithm АЛГОРИТМ --mode РЕЖИМ [--encrypt|--decrypt] --input ПУТЬ --output ПУТЬ [--key КЛЮЧ]
```

### Хеширование (команда dgst)

Команда для вычисления криптографических хешей файлов.

```bash
cryptocore dgst --algorithm АЛГОРИТМ --input ФАЙЛ [--output ВЫХОДНОЙ_ФАЙЛ]
```

- Поддерживаемые алгоритмы: `sha256`, `sha3-256`
- Вывод в формате: `HEX_ХЕШ  ПУТЬ_К_ФАЙЛУ` (совместимо с утилитами `*sum`)
- При указании `--output` строка с хешем записывается в файл в том же формате

Примеры:

```bash
# SHA-256
./cryptocore dgst --algorithm sha256 --input ./files/png-1.svg

# SHA3-256 и запись результата в файл
./cryptocore dgst --algorithm sha3-256 --input backup.tar --output backup.sha3

# Пустой ввод (ожидаемый SHA-256 для пустого файла)
./cryptocore dgst --algorithm sha256 --input empty.txt
# e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855  empty.txt
```

Примечание (Windows/MSYS2): файлы с кириллицей в имени могут не открываться из-за особенностей кодировок среды. Рекомендуется переименовать файл в ASCII-имя или использовать путь без не-ASCII символов.

### Обязательные аргументы

- `--algorithm АЛГОРИТМ`: Алгоритм шифрования (поддерживается: `aes`)
- `--mode РЕЖИМ`: Режим работы (`ecb`, `cbc`, `cfb`, `ofb`, `ctr`)
- `--encrypt` или `--decrypt`: Указание операции (требуется ровно один)
- `--input ПУТЬ`: Путь к входному файлу или директории
- `--output ПУТЬ`: Путь к выходному файлу или директории

### Опциональные аргументы

- `--key КЛЮЧ`: Ключ шифрования/дешифрования в виде **32-символьной шестнадцатеричной строки** (16 байт для AES-128)
  - При шифровании: если не указан, генерируется криптографически стойкий случайный ключ
  - При дешифровании: обязателен
- `--output ФАЙЛ`: Путь к выходному файлу (по умолчанию: <input>.enc или <input>.dec)
- `--iv IV`: Вектор инициализации (только для дешифрования режимов CBC, CFB, OFB, CTR)
  - 32-символьная шестнадцатеричная строка (16 байт)
  - Если не указан при дешифровании, читается из начала файла

### Режимы работы

#### ECB (Electronic Codebook)
- Самый простой режим
- **Не использует IV**
- Требует дополнение PKCS#7

#### CBC (Cipher Block Chaining)
- Каждый блок шифртекста зависит от предыдущих блоков
- Использует IV для первого блока
- Требует дополнение PKCS#7
- Безопасен для большинства применений

#### CFB (Cipher Feedback)
- Потоковый шифр
- Использует IV
- Не требует дополнения
- Самосинхронизирующийся

#### OFB (Output Feedback)
- Потоковый шифр
- Использует IV
- Не требует дополнения
- Генерирует поток ключа независимо от данных

#### CTR (Counter)
- Потоковый шифр
- Использует IV как начальное значение счетчика
- Не требует дополнения
- Параллелизуемый

### Обработка вектора инициализации (IV)

#### При шифровании (режимы CBC, CFB, OFB, CTR):
- IV генерируется автоматически с использованием криптографически стойкого генератора случайных чисел
- IV добавляется в начало выходного файла
- Формат файла: `[16 байт IV][Шифртекст]`

#### При дешифровании (режимы CBC, CFB, OFB, CTR):
- **Вариант 1**: IV читается из начала входного файла (по умолчанию)
- **Вариант 2**: IV передается явно через `--iv` (для совместимости с OpenSSL)

### Примеры

#### Пример 1: Шифрование одного файла (Sprint 1)

```bash
cryptocore --algorithm aes --mode ecb --encrypt \
  --key 000102030405060708090a0b0c0d0e0f \
  --input plaintext.txt \
  --output ciphertext.bin
```

#### Пример 2: Дешифрование одного файла (Sprint 1)

```bash
cryptocore --algorithm aes --mode ecb --decrypt \
  --key 000102030405060708090a0b0c0d0e0f \
  --input ciphertext.bin \
  --output decrypted.txt
```

#### Пример 3: Шифрование с автогенерацией имени файла

```bash
cryptocore --algorithm aes --mode ecb --encrypt \
  --key 000102030405060708090a0b0c0d0e0f \
  --input plaintext.txt
# Создаст файл plaintext.txt.enc
```

#### Пример 4: Шифрование в режиме CBC (Sprint 2)

```bash
cryptocore --algorithm aes --mode cbc --encrypt \
  --key 000102030405060708090a0b0c0d0e0f \
  --input plaintext.txt \
  --output ciphertext.bin
```

#### Пример 5: Дешифрование в режиме CBC с IV из файла

```bash
cryptocore --algorithm aes --mode cbc --decrypt \
  --key 000102030405060708090a0b0c0d0e0f \
  --input ciphertext.bin \
  --output decrypted.txt
```

#### Пример 6: Дешифрование в режиме CBC с явным IV

```bash
cryptocore --algorithm aes --mode cbc --decrypt \
  --key 000102030405060708090a0b0c0d0e0f \
  --iv aabbccddeeff00112233445566778899 \
  --input ciphertext.bin \
  --output decrypted.txt
```

#### Пример 8: Шифрование с автогенерацией ключа (Sprint 3)

```bash
cryptocore --algorithm aes --mode ctr --encrypt \
  --input plaintext.txt \
  --output ciphertext.bin
# Выведет: [INFO] Generated random key: 1a2b3c4d5e6f7890fedcba9876543210
```

#### Пример 9: Дешифрование с автогенерированным ключом

```bash
cryptocore --algorithm aes --mode ctr --decrypt \
  --key 1a2b3c4d5e6f7890fedcba9876543210 \
  --input ciphertext.bin \
  --output decrypted.txt
```

## Тестирование и проверка

### Тест полного цикла (Sprint 1)

Основной способ проверки корректности - **тест полного цикла**: шифрование файла с последующим дешифрованием должно дать файл, идентичный оригиналу.

```bash
# 1. Создайте тестовый файл
echo "Привет, CryptoCore!" > test.txt

# 2. Зашифруйте файл (ECB режим)
./cryptocore --algorithm aes --mode ecb --encrypt \
  --key 0123456789abcdef0123456789abcdef \
  --input test.txt \
  --output test.enc

# 3. Расшифруйте файл
./cryptocore --algorithm aes --mode ecb --decrypt \
  --key 0123456789abcdef0123456789abcdef \
  --input test.enc \
  --output test_dec.txt

# 4. Проверьте идентичность файлов
diff test.txt test_dec.txt
```

### Тест полного цикла (Sprint 2)

```bash
# 1. Создайте тестовый файл
echo "Привет, CryptoCore!" > test.txt

# 2. Зашифруйте файл (CBC режим)
./cryptocore --algorithm aes --mode cbc --encrypt \
  --key 0123456789abcdef0123456789abcdef \
  --input test.txt \
  --output test.enc

# 3. Расшифруйте файл (IV читается из файла)
./cryptocore --algorithm aes --mode cbc --decrypt \
  --key 0123456789abcdef0123456789abcdef \
  --input test.enc \
  --output test_dec.txt

# 4. Проверьте идентичность файлов
diff test.txt test_dec.txt
```

### Тест автогенерации ключей (Sprint 3)

```bash
# 1. Создайте тестовый файл
echo "Привет, CryptoCore!" > test.txt

# 2. Зашифруйте файл без указания ключа
./cryptocore --algorithm aes --mode ctr --encrypt \
  --input test.txt \
  --output test.enc
# Программа выведет: [INFO] Generated random key: 1a2b3c4d5e6f7890fedcba9876543210

# 3. Расшифруйте файл с сгенерированным ключом
./cryptocore --algorithm aes --mode ctr --decrypt \
  --key 1a2b3c4d5e6f7890fedcba9876543210 \
  --input test.enc \
  --output test_dec.txt

# 4. Проверьте идентичность файлов
diff test.txt test_dec.txt
```

### Тест уникальности ключей

```bash
# Запустите тест уникальности (1000 ключей)
cd tests
chmod +x test_csprng_uniqueness.sh
./test_csprng_uniqueness.sh
```

### NIST Statistical Test Suite

```bash
# 1. Сгенерируйте данные для NIST STS
cd tests
chmod +x generate_nist_data.sh
./generate_nist_data.sh

# 2. Скачайте и установите NIST STS
# 3. Запустите тесты на сгенерированных данных
# Подробные инструкции см. в выводе generate_nist_data.sh
```

### Совместимость с OpenSSL

CryptoCore полностью совместим с OpenSSL. Вы можете зашифровать файл в CryptoCore и расшифровать в OpenSSL, и наоборот.

#### Шифрование в CryptoCore, дешифрование в OpenSSL

```bash
# 1. Зашифруйте в CryptoCore
./cryptocore --algorithm aes --mode cbc --encrypt \
  --key 0123456789abcdef0123456789abcdef \
  --input plain.txt \
  --output cipher.bin

# 2. Извлеките IV из файла (первые 16 байт)
IV=$(xxd -p -l 16 cipher.bin | tr -d '\n')

# 3. Извлеките шифртекст (все, кроме первых 16 байт)
dd if=cipher.bin of=cipher_only.bin bs=16 skip=1 2>/dev/null

# 4. Расшифруйте в OpenSSL
openssl enc -aes-128-cbc -d \
  -K 0123456789abcdef0123456789abcdef \
  -iv $IV \
  -in cipher_only.bin \
  -out decrypted.txt

# 5. Проверьте
diff plain.txt decrypted.txt
```

#### Шифрование в OpenSSL, дешифрование в CryptoCore

```bash
# 1. Зашифруйте в OpenSSL
openssl enc -aes-128-cbc \
  -K 0123456789abcdef0123456789abcdef \
  -iv aabbccddeeff00112233445566778899 \
  -in plain.txt \
  -out openssl_cipher.bin

# 2. Расшифруйте в CryptoCore
./cryptocore --algorithm aes --mode cbc --decrypt \
  --key 0123456789abcdef0123456789abcdef \
  --iv aabbccddeeff00112233445566778899 \
  --input openssl_cipher.bin \
  --output decrypted.txt

# 3. Проверьте
diff plain.txt decrypted.txt
```

### Пакетная обработка

CryptoCore автоматически обрабатывает все файлы в директории при указании пути к директории:

```bash
# Шифрование всех файлов в директории
./cryptocore --algorithm aes --mode cbc --encrypt \
  --input ./files \
  --output ./encryptfiles

# Дешифрование всех файлов в директории
./cryptocore --algorithm aes --mode cbc --decrypt \
  --input ./encryptfiles \
  --output ./decryptfiles
```

При шифровании директории программа запросит новые имена для каждого файла и сохранит маппинг в файле `metadata.txt`.

### Автоматизированный тестовый скрипт

Тестовые скрипты находятся в директории `tests/`:

```bash
cd tests
./run_tests.sh              # Для Linux/macOS/MSYS2
./test_openssl_compat.sh    # Тесты совместимости с OpenSSL
```

Для Windows PowerShell:
```powershell
cd tests
.\test_manual.ps1
```

## Структура проекта

```
cryptocore/
├── src/                    # Директория исходного кода
│   ├── ecb.c              # Реализация режима ECB
│   ├── file_io.c          # Операции ввода-вывода файлов
│   ├── mouse_entropy.c    # Генерация ключа по движению мыши
│   └── modes/             # Реализации режимов шифрования
│       ├── cbc.c          # Режим CBC
│       ├── cfb.c          # Режим CFB
│       ├── ofb.c          # Режим OFB
│       ├── ctr.c          # Режим CTR
│       └── utils.c        # Утилиты (XOR, генерация IV)
├── include/               # Заголовочные файлы
│   ├── ecb.h              # Объявления ECB
│   ├── modes.h            # Объявления режимов
│   ├── file_io.h          # Объявления ввода-вывода файлов
│   └── mouse_entropy.h    # Объявления генерации ключа
├── tests/                 # Тестовые файлы и скрипты
│   ├── run_tests.sh       # Автоматизированный тестовый скрипт
│   └── test_openssl_compat.sh  # Тесты совместимости с OpenSSL
├── build/                 # Артефакты сборки (создаются при компиляции)
├── main.c                 # Парсер CLI и основная логика программы
├── Makefile               # Система сборки
└── README.md              # Этот файл
```

## Детали реализации

### AES-128

- **Алгоритм**: AES (Advanced Encryption Standard)
- **Размер ключа**: 128 бит (16 байт)
- **Размер блока**: 128 бит (16 байт)
- **Библиотека**: OpenSSL (libcrypto)

### Криптографически стойкий генератор случайных чисел (CSPRNG)

- **Библиотека**: OpenSSL RAND_bytes()
- **Источник энтропии**: Операционная система (/dev/urandom на Unix, CryptGenRandom на Windows)
- **Безопасность**: Криптографически стойкий генератор, подходящий для генерации ключей и IV
- **Использование**: Автоматическая генерация ключей при шифровании без `--key`

### Генерация ключа по движению мыши (дополнительная функциональность)

- **Платформа**: Windows (использует Windows API)
- **Энтропия**: Координаты курсора, временные метки, системная энтропия
- **Безопасность**: Комбинирование пользовательской энтропии с криптографически стойким генератором
- **Автоматизация**: Ключ генерируется автоматически при шифровании

### Режимы и дополнение

| Режим | Требует IV | Требует дополнение | Тип |
|-------|-----------|-------------------|-----|
| ECB   | Нет       | Да (PKCS#7)       | Блочный |
| CBC   | Да        | Да (PKCS#7)       | Блочный |
| CFB   | Да        | Нет               | Потоковый |
| OFB   | Да        | Нет               | Потоковый |
| CTR   | Да        | Нет               | Потоковый |

### Дополнение PKCS#7

Для режимов ECB и CBC используется дополнение PKCS#7:
- Гарантирует, что открытый текст кратен размеру блока (16 байт)
- Каждый байт дополнения содержит количество добавленных байтов дополнения

**Пример**:
- Вход: `"Привет"` (12 байт в UTF-8)
- После дополнения: `"Привет\x04\x04\x04\x04"` (16 байт)

### Примечание о безопасности

**Режим ECB не рекомендуется для производственного использования**, так как он не обеспечивает семантическую безопасность. Идентичные блоки открытого текста производят идентичные блоки шифртекста.

Рекомендуемые режимы для продакшена:
- **CBC** - для общего назначения
- **CTR** - когда требуется параллелизация
- **GCM** - когда требуется аутентификация (будет добавлено в будущих версиях)

### Криптографические хеши (безопасность)

- **SHA-256**: стандарт де-факто для целостности данных, широкая поддержка, стойкость к коллизиям на практике
- **SHA3-256**: более новый стандарт на основе губки Keccak, альтернативная конструкция, высокая криптостойкость
- Оба алгоритма реализованы с потоковой обработкой файлов (константное потребление памяти)

## Обработка ошибок

CryptoCore предоставляет четкие сообщения об ошибках:

- **Отсутствующие аргументы**: Указывает, какой обязательный аргумент отсутствует
- **Неверный формат ключа/IV**: Ключ и IV должны быть 32 шестнадцатеричных символа
- **Ошибки файлов**: Четкие сообщения о том, что файл не найден, проблемы с правами доступа и т.д.
- **Неверное дополнение**: Обнаруживает поврежденный или измененный шифртекст
- **Неверный IV**: Проверяет длину и формат IV
- **Ошибки директорий**: Проблемы с созданием выходных директорий или чтением входных
- **Ошибки метаданных**: Проблемы с чтением/записью файла маппинга имен файлов

Все ошибки выводятся в `stderr`, и программа завершается с ненулевым кодом состояния.

## Сборка на Windows

### Требования

- **MSYS2** с MinGW-w64
- **OpenSSL** (устанавливается через `pacman -S mingw-w64-x86_64-openssl`)

### Сборка

```bash
# В MSYS2 MinGW 64-bit терминале
cd /c/school/kripta
make clean
make
```

Или используйте batch-файл:

```cmd
build.bat
```

### Использование

```cmd
.\cryptocore.exe --algorithm aes --mode cbc --encrypt --input .\files --output .\encryptfiles
```
## Лицензия

Этот проект распространяется под лицензией MIT. См. файл `LICENSE` для подробностей.

## Вклад в проект

Мы приветствуем вклад в развитие CryptoCore! Пожалуйста, создавайте Issues для сообщения об ошибках и Pull Requests для предложения улучшений.

## Поддержка

Если у вас возникли проблемы или вопросы:

1. Проверьте раздел [Обработка ошибок](#обработка-ошибок)
2. Убедитесь, что все зависимости установлены корректно
3. Создайте Issue в репозитории проекта с подробным описанием проблемы